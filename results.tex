% -*- root: article.tex -*-

% SOBRE N√ÉO USAR FRAGMENTS / MOVER PARA RESULTADOS
% Uma situa\c{c}\~ao interessante \'e que diversas dessas respostas indicavam que n\~ao se deve usar \textsc{Fragments} por\'em n\~ao apresentavam nenhum argumento sobre o motivo, por exemplo: ``Eu tento evit\'a-los.' (tradu\c{c}\~ao livre). Essas respostas inicialmente seriam desconsideradas, mas pela quantidade de repeti\c{c}\~oes obtidas, 10 no caso, optamos por considerar. 

% Em seguida, realizamos diversas itera\c{c}\~oes nas respostas sobre boas e m\'as pr\'aticas consideradas a fim de categoriz\'a-las em algum novo smell Android ou algum smell pr\'e-existente. Essas itera\c{c}\~oes consistiram em analisar resposta a resposta e atribuir uma ou mais categorias de algum poss\'ivel novo smell Android ou pr\'e-existente. Foram realizadas diversas itera\c{c}\~oes de categoriza\c{c}\~ao com o objetivo de normalizar as categorias, ou seja, evitar sin\^onimos e hom\^onimos. Um sin\^onimo \'e o mesmo conceito com dois nomes diferentes e hom\^onimos s\~ao dois conceitos diferentes com o mesmo nome. 

% Durante a categoriza\c{c}\~ao, uma mec\^anica que consideramos importante para a normaliza\c{c}\~ao das categorias, foi a cria\c{c}\~ao de uma lista de categorias, onde a cada nova categoria atribu\'ida, increment\'avamos a lista e preench\'iamos com descri\c{c}\~oes que indicavam que tipo de boa ou m\'a pr\'atica estava recebendo aquela categoria. Esta mec\^anica ajudou a evitar hom\^onimos e sin\^onimos e serviu como base para a defini\c{c}\~ao e avalia\c{c}\~ao da relev\^ancia dos \textit{smells} a serem trabalhados nos pr\'oximos passos.

O \'ultimo passo foi a etapa que denominamos de \textit{divis\~ao}. Nesse passo, as respostas que receberam mais de uma categoria foram divididas em duas ou mais respostas (de acordo com o n\'umero de categorias identificadas). Por exemplo, a resposta \textit{"N\~ao fazer Activities serem callbacks de execu\c{c}\~oes ass\'incronas. Herdar sempre das classes fornecidas pelas bibliotecas de suporte, nunca diretamente da plataforma"} indica na primeira ora\c{c}\~ao uma categoria e na segunda ora\c{c}\~ao outra categoria. Ao divid\'i-la mantivemos o texto da resposta apenas relativo a categoria, como se fossem duas respostas v\'alidas. Em algumas respostas que foram divididas n\~ao pudemos dividir o texto pois a resposta completa era necess\'aria para entender ambas as categoriza\c{c}\~oes, nesses casos, mantivemos a resposta original, mesmo que duplicada, e categorizamos cada uma de forma diferente. Ap\'os as divis\~oes, conclu\'imos com 388 respostas sobre boas e m\'as pr\'aticas no \textit{front-end} Android, sendo cada uma com apenas uma categoria. 

%  MOVER PARA RESULTADOS
% Ao final de todas as etapas, conclu\'imos com 388 respostas sobre boas e m\'as pr\'aticas distribu\'idas em 47 categorias. 

\subsection{An\'alise e Defini\c{c}\~ao dos Smells}
\label{sub:analisys-definition}

Nosso objetivo nesta etapa foi entender quais \textit{smells}, dos 47 identificados, eram mais recorr\^entes. Para isso, contabilizamos cada \textit{smell}, em quantas respostas ele aparecia, ou seja, se duas respostas foram categorizadas com o \textit{smell} "A" ent\~ao diz-se que esse \textit{smell} tem contagem 2. Depois da contagem, elaboramos intervalos que indicam recorr\^encia ALTA, maior ou igual a 20, M\'EDIA, dentre 6 e 19 e BAIXA, dentre 3 e 5. Abaixo de 3 classificamos como IRRELEVANTE. Obtemos o seguinte resultado:

\begin{table}[h]
\centering
\caption{Smells identificados vs. recorr\^encia percebida pelos participantes do question\'ario}
\small
\begin{tabular}{p{3cm}|p{4cm}}
\toprule
\textbf{Recorr\^encia} & \textbf{Quantidade de Smells} \\
\hline
Alta  			& 5 \\
M\'edia 		& 17 (1 \textit{smell} tradicional) \\
Baixa			& 5 \\
Irrelevante 	& 20 \\
\toprule
\end{tabular}
\label{tab:DadosDemograficos2}
\end{table}

Os irrelevantes foram desconsiderados nesta etapa de defini\c{c}\~ao. Os demais foram definidos com a ajuda das respostas dos participantes. Para cada \textit{smell} definimos os seguintes t\'opicos: 

\begin{itemize} 
	\item[$\textasteriskcentered$] \textbf{Quando ocorre}. Indicamos os motivos pelo qual foi considerado uma m\'a pr\'atica.   
	\item[$\textasteriskcentered$] \textbf{Contexto/exemplo}. Indicamos algum exemplo ou contexto pr\'atico. 
	\item[$\textasteriskcentered$] \textbf{Elementos afetados}. Eventualmente algum \textit{smell} afeta mais de um elemento, nesse t\'opico abordamos em quais os elementos este \textit{smell} pode estar presente. 
	\item[$\textasteriskcentered$] \textbf{Solu\c{c}\~ao}. Indicamos poss\'iveis refatora\c{c}\~oes para reduzir ou eliminar o \textit{smell}. \\
\end{itemize}

\'E importante ressaltar que todas as defini\c{c}\~oes dos \textit{smells} foram apoiadas nas respostas dos participantes. Se os participantes n\~ao indicaram algum t\'opico para algum \textit{smell}, o mesmo n\~ao foi definido. \\


\subsection{Android Code Smells}
\label{sub:Android-code-smells}

\subsubsection{Duplicated Styles Attributes (DSA)}

\textbf{Ocorre quando} mais de um view de um ou mais layouts usam o mesmo conjunto de atributos para definir sua apar\^encia. No estilo \textbf{ocorre quando} se v\^e mais de um style repetindo o mesmo conjunto de atributos e valores. Os \textbf{elementos afetados} s\~ao xmls de layout ou estilo. A \textbf{heur\'istica para detect\'a-lo} \'e identificar um conjunto de atributos que se repetem em um ou mais views de um ou mais layouts. Sua \textbf{solu\c{c}\~ao} \'e extrair um estilo com o conjunto de atributos repetidos relacionados a caracter\'isticas de exibi\c{c}\~ao da view. 

Considere o seguinte \textbf{contexto} onde o \texttt{TextView} abaixo \'e usado em dois momentos no mesmo layout (exemplo extra\'ido da documenta\c{c}\~ao do Android\footnote{https://developer.Android.com/guide/topics/ui/themes.html}):

\begin{lstlisting}[
	language=XML, 
	caption={\texttt{TextView} usado em mais de um layout e com estilo definido por atributos}, 
	label={lst:AndroidManifest}
]
<TextView
    Android:layout-width="match-parent"
    Android:layout-height="wrap-content"
    Android:textColor="#00FF00"
    Android:typeface="monospace"
    Android:text="@string/hello" />
\end{lstlisting}

Uma op\c{c}\~ao seria extrair o estilo acima para um recurso de estilos:

\begin{lstlisting}[
	language=XML, 
	caption={\texttt{TextView} usando estilo ao inv\'es de atributos separados}, 
	label={lst:AndroidManifest}
]
<TextView
    Android:layout-width="match-parent"
    Android:layout-height="wrap-content"
    Android:textAppearance="@style/CodeFont"
    Android:text="@string/hello" />
\end{lstlisting}

Arquivo de estilo com o estilo CodeFont criado:

\begin{lstlisting}[
	language=XML, 
	caption={\texttt{TextView} usando estilo em vez de atributos separados}, 
	label={lst:AndroidManifest}
]
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="CodeFont" ...>
        <item name="Android:textColor">
        	#00FF00
        </item>
        <item name="Android:typeface">
        	monospace
        </item>
    </style>
</resources>
\end{lstlisting}


\subsubsection{Suspicious Extra Knowledge About Behavior (SEKAB)}

\textbf{Ocorre quando} uma view possui um conhecimento maior do que o considerado aceit\'avel sobre os detalhes de seu comportamento. Para este smell identificamos por meio das respostas que tr\^es elementos da view \textbf{podem ser afetados} por ele, s\~ao: \textsc{activity}, \textsc{fragment} e \textsc{adapter}. E a depender de qual view est\'a se tratando, o que \'e considerado aceit\'avel pode mudar. Sendo assim, chegamos a seguinte escala de conhecimento aceit\'avel:

\begin{itemize} 
	\item[$\circ$] n\'ivel 1 - implementa\c{c}\~ao de classe concreta;
	\item[$\circ$] n\'ivel 2 - atrav\'es de \textit{implements} (polimorfismo);
	\item[$\circ$] n\'ivel 3 - atrav\'es de classe an\^onima;
	\item[$\circ$] n\'ivel 4 - atrav\'es de \textit{inner class}.
\end{itemize}

Para \textsc{Adapter}s, apenas o n\'ivel 1 foi considerado como aceit\'avel. Para \textsc{Activity}s e \textsc{Fragment}s, at\'e o n\'ivel 3 \'e considerado aceit\'avel, sendo que houveram indica\c{c}\~oes positivas e nenhuma negativa sobre o uso do n\'ivel 1, houveram indica\c{c}\~oes positivas e negativas sobre o n\'ivel 2 e houveram apenas indica\c{c}\~oes negativas sobre o n\'ivel 3 e 4. 

Como \textbf{solu\c{c}\~ao}, segundo as respostas R666 e R672, \textit{"adapters devem ser o mais est\'upido poss\'ivel"} (tradu\c{c}\~ao livre). Podemos dizer ent\~ao que se for necess\'ario atribuir algum comportamento para alguma view que est\'a sendo populada, isso dever\'a ser feito usando a m\'etodo descrito para o n\'ivel 1. J\'a para \textsc{Activity}s e \textsc{Fragment}s a toler\^ancia de conhecimento aumenta at\'e o n\'ivel 3, sendo 1 e 2 os mais indicados e 3 toler\'avel \'as vezes (aqui talvez existam dois thresholds como n\'umero de linhas do m\'etodo do evento ou mesmo quantidade de classes an\^onimas na classe). O n\'ivel 4 \'e inaceit\'avel para todos os elementos afetados por este smell.

Os \textbf{elementos afetados} s\~ao: \textsc{activity}, \textsc{fragment} e \textsc{adapters}. As \textbf{heur\'isticas} de detec\c{c}\~ao s\~ao:

\begin{itemize} 
	\item[$\circ$] [n\'ivel 4] se existe uma ou mais inner class de listener
	\item[$\circ$] [n\'ivel 3] se existe um certo n\'umero de classes an\^onimas
	\item[$\circ$] [n\'ivel 2 e 3] se LOC dentro do m\'etodo do listener - an\^onimo ou sobreescrito \'e maior que 1
\end{itemize}


\subsubsection{Flex Adapter (FA)}

\textbf{Ocorre quando} um adapter precisa de condicionais para decidir se determinada view deve estar visivel ou n\~ao ou quando um adapter recebe mais de um tipo de objeto para ser colocado na view.

Como \textbf{solu\c{c}\~ao}, R578 e R647 sugerem que, caso os condicionais sejam para decidir sobre a exibi\c{c}\~ao ou n\~ao de views, separa em duas ou mais views. Sobre adaptar mais de um tipo de objeto, a resposta R577 sugere a delega\c{c}\~ao para outros adapters especialistas em lidar com cada objeto.


\subsubsection{Magic Resource (MR)}

\textbf{Ocorre quando} se encontra uma string, integer, color ou dimension em arquivos que n\~ao sejam os seus respectivos onde \'e poss\'ivel atribuir um nome e reutiliz\'a-los. 


\subsubsection{Resource Name Pattern (RNP)}

\textbf{Ocorre quando} seus recursos n\~ao seguem um padr\~ao de nomenclatura. Tornando dif\'icil encontr\'a-los e reaproveit\'a-los. A seguir apresentamos uma pasta res desorganizada e despadronizada:

\begin{lstlisting}[
	language=XML, 
	caption={Recursos de aplica\c{c}\~ao sem padr\~ao de nomenclatura}, 
	label={lst:AndroidManifest}
]
- res
  - layout
    - tela-de-login.xml
    - cadastro-act.xml
    - propaganda-frag.xml
    - item1.xml
    - item2.xml
  - values
    - strings.xml 
    - styles.xml
    - colors.xml
  - drawables
    - ic-app.jpg
    - tela-cadastro.png
    - bg.xml
\end{lstlisting}

Agora, uma pasta res seguindo as sugest\~oes de solu\c{c}\~ao:

\begin{lstlisting}[
	language=XML, 
	caption={Recursos de aplica\c{c}\~ao com padr\~ao de nomenclatura}, 
	label={lst:AndroidManifest}
]
- res 
  - layout 
    - activity-login.xml 
    - activity-cadastro.xml 
    - fragment-propaganda.xml 
    - item-lista-propaganda-tipo1.xml 
    - item-lista-propaganda-tipo2.xml 
  - values 
    - strings-login.xml  
    - strings-cadastro.xml  
    - strings-propaganda.xml  
    - styles-login.xml 
    - colors.xml 
  - drawables 
    - icone-app.jpg 
    - icone-cadastro.png 
    - background.xml 
\end{lstlisting}

Em se falando de strings resources, segundo P27 "Iniciar o nome de uma string com o nome da tela onde vai ser usada", e P2 refor\c{c}a essa ideia sugerindo <screen>-<type>-<text>. Eg.: welcome-message-title, registration-field-name, registration-hint-edit-name. P34 e P4 sugere que o nome do elemento usando a string como parte do nome da string: dialog.STRING-NAME or hint.STRING-NAME

Em se falando de layout resources, P11 sugere sempre come\c{c}ar com "activity-", "fragment-", "ui-" (para UI customizadas) j\'a P12 sugere o uso de sufixos, como por exemplo "xxx-activity".

Sobre drawables e estilos n\~ao foi sugerida uma maneira espec\'ifica de nomenclatura, apenas enfatizaram para definir um padr\~ao e us\'a-lo em toda a aplica\c{c}\~ao.


\subsubsection{Messy String Resources (MStringR)} 

\textbf{Ocorre quando} se tem um \'unico arquivo strings.xml para guardar todas as strings da aplica\c{c}\~ao ou quando os arquivos string encontram-se desorganizados, sem seguir nenhum padr\~ao espec\'ifico. Como \textbf{solu\c{c}\~ao}, P28 e P42 sugerem separar as strings por arquivos que indiquem a qual tela aquelas strings pertencem. P42 tamb\'em sugere ter um arquivo de strings comuns a toda aplica\c{c}\~ao. P41 sugere ainda separar os arquivos de acordo com contextos como: urls, mensagens de erro. P32 sugere usar um \'unico arquivo por\'em separando-o em blocos, onde casa bloco indica uma tela.



\subsubsection{Messy Style Resources (MStyleR)} 

\textbf{Ocorre quando} se tem um \'unico arquivo styles.xml para guardar todos os estilos e temas da aplica\c{c}\~ao ou quando os arquivos styles encontram-se desorganizados, sem seguir nenhum padr\~ao espec\'ifico. Como \textbf{solu\c{c}\~ao}, P7, P42 e P40 sugerem criar um styles para estilos de componentes e outro para temas. P8 j\'a sugere quebrar em v\'arios arquivos estilos e um para o tema.



\subsection{Interpreta\c{c}\~ao dos Dados}

As vezes o que era indicado como boa pr\'atica para um elemento era um smell percebido em outro elemento, por exemplo, a R1 diz que \textit{"Sempre que noto ter mais de um [layout] resource usando o mesmo estilo eu tento mov\^e-lo [o estilo] para meu recurso de estilo"} (tradu\c{c}\~ao livre) ao responder sobre boa pr\'atica para o style resource, por\'em esta resposta foi considerada para definir o smell Duplicated Styles Attributes que \'e percebido em recursos de layout ou styles.


\subsection{Afirma\c{c}\~ao sobre o \textit{front-end} Android}

Uma opini\~ao que foi un\^anime em muitas respostas foi que de fato, desenvolvedores tratam \textsc{Activitys}, \textsc{Fragments} e \textsc{Adapters} como elementos do front-end Android, conforme constatamos na se\c{c}\~ao 3.1. Isso pode ser observado diversas vezes com respostas por exemplo, P25 indicou como boa pr\'atica na Activity "Nenhuma l\'ogica [de neg\'ocio] aqui" (tradu\c{c}\~ao livre), o P40 afirma sobre m\'a pr\'atica em adapter \'e \textit{"L\'ogica de neg\'ocio em adapters \'e n\~ao-n\~ao"} (tradu\c{c}\~ao livre), ao falarem sobre fragments, muitos indicaram \textit{"O mesmo da Activity"}. Ou seja, primeiramente estas respostas refor\c{c}am nossa defini\c{c}\~ao inicial sobre elementos que compo\^em o front-end Android, e por outro lado, vimos que muitas vezes fragments s\~ao tratados como Activitys, ao se falar de boas e m\'as pr\'aticas de c\'odigo.

